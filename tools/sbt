#!/usr/bin/env bash
set -euo pipefail

# Write a Bash script named `sbt` that implements command-line argument parsing with two subcommands:

# 1. `sbt install {package}`
# 2. `sbt download {package}`

# Requirements:
# - The `install` command accepts:
#   - `--link` or `--nolink` (mutually exclusive switches)
#   - `--prefix={path}` or `--prefix {path}` (both formats supported)
#   - `--arch={osname_arch}` or `--arch {osname_arch}` (both formats supported)
# - The `download` command accepts.
#   - `--arch={osname_arch}` or `--arch {osname_arch}` (both formats supported)
# - Use **GNU getopt** for robust parsing.
# - Show helpful usage output when arguments are missing or invalid.
# - The script should be written **entirely in English**, cleanly formatted, with clear comments and example usage.
# - Include sample output and a short description of script features at the end.
# - Keep the code as concise as possible, with as few lines of code as possible.

function link() {
  local src_dir=$1
  local dst_dir=$2
  find "$src_dir" \( -type f -o -type l \) | while read -r file; do
    rel_path="${file#$src_dir/}"
    dest_file="$dst_dir/$rel_path"
    mkdir -p "$(dirname "$dest_file")"
    if [[ -L $dest_file ]] || [[ -f $dest_file ]]; then
      rm "$dest_file"
    fi
    ln -s -r "$file" "$dest_file"
  done
}

function download_pkg() {
  local name=$1
  local arch=$2

  local store_path=$3
  local cache_path=${XDG_CACHE_HOME:-${HOME}/.cache}/sbt/download/$arch

  echo "> Downloading $name($arch) to $store_path, and cache_path=$cache_path"

  # $(echo $(uname -s)-$(uname -m) | tr '[:upper:]' '[:lower:]') # linux_amd64/darwin_arm64

  mkdir -p $cache_path
  rm -rf $cache_path/$name.tar.gz
  curl -sSL https://github.com/curoky/static-binaries/releases/download/v1.0/${name}.${arch}.tar.gz \
    -o $cache_path/${name}.tar.gz
  rm -rf $store_path
  mkdir -p $store_path
  tar -x --gunzip -f $cache_path/${name}.tar.gz -C $store_path --strip-components=1
}

function install_pkg() {
  local name=$1
  local arch=$2

  local prefix=$3
  local link=$4
  
  local store_path=$prefix/store/$name
  
  echo "> Installing $name($arch) to $store_path, and linked=$link_mode"

  download_pkg $name $arch $store_path
  if [[ $link == "1" ]]; then
    link $store_path $prefix
  fi
}

show_usage() {
    cat <<EOF
Usage:
  sbt install [OPTIONS] <package>
  sbt download [OPTIONS] <package>

Subcommands:
  install     Install a package.
  download    Download a package.

Options for 'install':
  --link | --nolink              Choose whether installation links or not (mutually exclusive).
  --prefix PATH or --prefix=PATH Installation prefix path.
  --arch ARCH or --arch=ARCH     Specify architecture (e.g. linux_x86_64).

Options for 'download':
  --arch ARCH or --arch=ARCH     Specify architecture.

Examples:
  sbt install --link --prefix=/usr/local hello
  sbt install --nolink --arch linux_x86_64 something
  sbt download --arch linux_arm64 toolname
EOF
}

[ $# -lt 1 ] && { show_usage; exit 1; }

cmd="$1"; shift

case "$cmd" in
  install)
    ARGS=$(getopt -o '' --long link,nolink,prefix:,arch: -n sbt -- "$@") || { show_usage; exit 1; }
    eval set -- "$ARGS"

    link_mode="1"
    prefix="/opt/sbt"
    arch=$(echo $(uname -s)-$(uname -m) | tr '[:upper:]' '[:lower:]')

    while true; do
      case "$1" in
        --link) link_mode="1"; shift ;;
        --nolink) link_mode="0"; shift ;;
        --prefix) prefix="$2"; shift 2 ;;
        --prefix=*) prefix="${1#*=}"; shift ;;
        --arch) arch="$2"; shift 2 ;;
        --arch=*) arch="${1#*=}"; shift ;;
        --) shift; break ;;
        *) show_usage; exit 1 ;;
      esac
    done
  
    [ $# -lt 1 ] && { echo "Error: missing package."; show_usage; exit 1; }
    pkg="$1"

    [ "$link_mode" = "" ] && { echo "Error: --link or --nolink required."; exit 1; }

    install_pkg $pkg $arch $prefix $link_mode
    ;;

  download)
    ARGS=$(getopt -o '' --long arch: -n sbt -- "$@") || { show_usage; exit 1; }
    eval set -- "$ARGS"

    arch=$(echo $(uname -s)-$(uname -m) | tr '[:upper:]' '[:lower:]')

    while true; do
      case "$1" in
        --arch) arch="$2"; shift 2 ;;
        --arch=*) arch="${1#*=}"; shift ;;
        --) shift; break ;;
        *) show_usage; exit 1 ;;
      esac
    done

    [ $# -lt 1 ] && { echo "Error: missing package."; show_usage; exit 1; }
    pkg="$1"
    echo $PWD
    download_pkg $pkg $arch $PWD/$pkg
    ;;

  *)
    echo "Error: Unknown subcommand '$cmd'"
    show_usage
    exit 1
    ;;
esac